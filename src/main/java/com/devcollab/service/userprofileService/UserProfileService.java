package com.devcollab.service.userprofileService;

import com.devcollab.domain.profileEnity.User;
import com.devcollab.dto.UserProfileDto.*;
import com.devcollab.repository.userprofileRepo.UserProfileRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;

@Service
@RequiredArgsConstructor // <-- TH√äM V√ÄO: H·ªó tr·ª£ constructor injection
@Transactional(readOnly = true)
public class UserProfileService {

    private final UserProfileRepository userProfileRepository;
    private final CloudinaryService cloudinaryService;

    // üßç‚Äç‚ôÇÔ∏è 1. Xem profile c√° nh√¢n (c√≥ project, task, collaborator)
    public UserProfileDto getMyProfile(Long myUserId) {
        User user = userProfileRepository.findByUserId(myUserId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<ProjectSummaryDto> projects = user.getProjectMemberships().stream()
                .map(pm -> new ProjectSummaryDto(
                        pm.getProject().getProjectId(),
                        pm.getProject().getProjectName() // <-- Gi·∫£ ƒë·ªãnh b·∫°n ƒë√£ s·ª≠a Entity Project t·ª´ 'projectName' -> 'name'
                ))
                .distinct() // Gi·ªù 'distinct' ho·∫°t ƒë·ªông ƒë√∫ng tr√™n object
                .toList();

        // THAY ƒê·ªîI: Logic mapping sang DTO con (TaskSummaryDto)
        List<TaskSumaryDto> tasks = user.getAssignedTasks().stream()
                .map(t -> new TaskSumaryDto(
                        t.getTaskId(),
                        t.getTitle()
                ))
                .toList();

        List<CollaboratorDto> collaborators = userProfileRepository
                .findCollaboratorsByUserId(myUserId)
                .stream()
                .map(CollaboratorDto::fromEntity)
                .toList();

        return new UserProfileDto(
                user.getAvatarUrl(),
                user.getName(),
                user.getBio(),
                user.getSkills(),
                user.getEmail(),
                projects,
                tasks,
                collaborators
        );
    }

    // üëÄ 2. Xem profile ng∆∞·ªùi kh√°c (ch·ªâ info + collaborators)
    public UserProfileDto getOtherUserProfile(Long targetUserId) {
        User user = userProfileRepository.findByUserId(targetUserId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        List<CollaboratorDto> collaborators = userProfileRepository
                .findCollaboratorsByUserId(targetUserId)
                .stream()
                .map(CollaboratorDto::fromEntity)
                .toList();

        return new UserProfileDto(
                user.getAvatarUrl(),
                user.getName(),
                user.getBio(),
                user.getSkills(),
                null,          // kh√¥ng hi·ªÉn th·ªã email ng∆∞·ªùi kh√°c
                null,          // kh√¥ng hi·ªÉn th·ªã project
                null,          // kh√¥ng hi·ªÉn th·ªã task
                collaborators  // v·∫´n hi·ªÉn th·ªã ng∆∞·ªùi l√†m vi·ªác c√πng
        );
    }

    //3. C·∫≠p nh·∫≠t th√¥ng tin profile c√° nh√¢n
    @Transactional // Ghi ƒë√® readOnly = true ·ªü tr√™n
    public UserProfileDto updateMyProfile(Long myUserId, UserPatchDto patchDto) {

        User user = userProfileRepository.findById(myUserId)
                .orElseThrow(() -> new RuntimeException("User not found: " + myUserId));

        // Ki·ªÉm tra t·ª´ng tr∆∞·ªùng trong DTO ƒë·ªÉ h·ªó tr·ª£ PATCH (c·∫≠p nh·∫≠t t·ª´ng ph·∫ßn)
        if (patchDto.getName() != null) {
            user.setName(patchDto.getName());
        }
        if (patchDto.getBio() != null) {
            user.setBio(patchDto.getBio());
        }
        if (patchDto.getSkills() != null) {
            user.setSkills(patchDto.getSkills());
        }
        if (patchDto.getAvatarUrl() != null) {
            // Cho ph√©p client set URL th·ªß c√¥ng (v√≠ d·ª•, sau khi upload)
            user.setAvatarUrl(patchDto.getAvatarUrl());
        }

        // L∆∞u c√°c thay ƒë·ªïi v√†o DB
        userProfileRepository.save(user);

        // Tr·∫£ v·ªÅ profile M·ªöI NH·∫§T (bao g·ªìm c·∫£ tasks, projects...)
        return getMyProfile(myUserId);
    }

    // 4. Upload ·∫£nh ƒë·∫°i di·ªán l√™n Cloudinary v√† tr·∫£ v·ªÅ URL
    @Transactional // Ghi ƒë√® readOnly = true
    public String updateMyAvatar(Long myUserId, MultipartFile avatarFile) throws IOException {

        User user = userProfileRepository.findById(myUserId)
                .orElseThrow(() -> new RuntimeException("User not found: " + myUserId));

        if (avatarFile == null || avatarFile.isEmpty()) {
            throw new RuntimeException("Avatar file is empty or missing");
        }

        // 1. Upload file l√™n Cloudinary
        String newAvatarUrl = cloudinaryService.uploadFile(avatarFile, "devcollab/avatars");

        // 2. C·∫≠p nh·∫≠t URL m·ªõi cho User
        user.setAvatarUrl(newAvatarUrl);

        // 3. L∆∞u v√†o DB
        userProfileRepository.save(user);

        // 4. Tr·∫£ v·ªÅ URL m·ªõi
        return newAvatarUrl;
    }
}
