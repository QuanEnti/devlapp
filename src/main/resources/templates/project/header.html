<header
  th:fragment="header"
  class="bg-white p-4 flex justify-between items-center shadow-md sticky top-0 z-20 h-16 border-b border-gray-200"
>
  <!-- üîπ Logo -->
  <div class="flex items-center space-x-3 w-64 flex-shrink-0">
    <img
      th:src="@{/photo/logo1.png}"
      alt="DevCollab Logo"
      class="w-9 h-9 rounded-lg shadow-sm"
    />
    <span class="text-2xl font-extrabold text-blue-700 tracking-wider">
      DevCollab
    </span>
  </div>

  <!-- üîπ Search -->
  <div class="flex-grow flex justify-center mx-10">
    <div class="relative w-full max-w-xl">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-5 w-5 absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-400"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        id="searchIcon"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
        />
      </svg>

      <input
        id="searchInput"
        type="text"
        placeholder="Search for anything..."
        class="border border-gray-200 rounded-full pl-12 pr-4 py-2 w-full focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-gray-50 text-sm shadow-sm"
      />

      <div
        id="searchDropdown"
        class="hidden absolute left-0 mt-3 w-full bg-white border border-gray-200 rounded-xl shadow-lg z-30"
      >
        <div class="p-3 border-b bg-gray-50 font-semibold text-gray-700">
          K·∫øt qu·∫£ t√¨m ki·∫øm
        </div>
        <div id="searchResults" class="max-h-80 overflow-y-auto">
          <p class="p-4 text-gray-500 text-sm text-center">
            Nh·∫≠p ƒë·ªÉ b·∫Øt ƒë·∫ßu t√¨m ki·∫øm...
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- üîπ Right side -->
  <div class="flex items-center space-x-6 flex-shrink-0">
    <!-- üîî Notification button -->
    <div class="relative">
      <button
        id="open-notif-btn"
        class="relative bg-white/90 text-gray-700 hover:bg-white px-3 py-2 rounded-md shadow-sm"
      >
        üîî
        <span
          id="notif-dot"
          class="absolute top-1 right-1 w-2 h-2 bg-red-500 rounded-full hidden"
        ></span>
        <span
          id="notif-count-badge"
          class="hidden absolute -top-1 -right-2 text-[10px] px-1.5 py-0.5 rounded-full bg-red-600 text-white font-semibold min-w-[18px] text-center"
        ></span>
      </button>
    </div>

    <!-- üîî Notification panel -->
    <div
      id="notif-panel"
      class="hidden absolute right-6 top-16 w-[420px] bg-white rounded-xl shadow-xl border border-gray-200 overflow-hidden z-[150]"
    >
      <div
        class="flex items-center justify-between px-4 py-3 border-b bg-gray-50 relative"
      >
        <h2 class="font-semibold text-gray-800 text-[15px]">Th√¥ng b√°o</h2>

        <div class="flex items-center gap-3">
          <label
            class="flex items-center text-sm text-gray-600 cursor-pointer select-none"
          >
            <span class="mr-1">Ch·ªâ hi·ªÉn th·ªã ch∆∞a ƒë·ªçc</span>
            <input id="toggle-unread" type="checkbox" class="sr-only peer" />
            <div
              class="w-10 h-5 bg-gray-300 rounded-full relative after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:w-4 after:h-4 after:bg-white after:rounded-full after:transition-all peer-checked:bg-blue-600 peer-checked:after:translate-x-5"
            ></div>
          </label>

          <button
            id="mark-all-read"
            class="hidden text-sm text-blue-600 hover:text-blue-800 font-medium transition"
          >
            ƒê√°nh d·∫•u t·∫•t c·∫£ ƒë√£ ƒë·ªçc
          </button>

          <!-- ‚ãØ Menu Button -->
          <div class="relative">
            <button
              id="notif-options-btn"
              class="text-gray-500 hover:text-gray-800 text-xl px-2 py-1 rounded transition"
            >
              ‚ãØ
            </button>

            <!-- Dropdown menu -->
            <div
              id="notif-options-menu"
              class="hidden absolute right-0 mt-2 w-64 bg-white border border-gray-200 rounded-xl shadow-lg overflow-hidden z-[999]"
            >
              <ul class="divide-y divide-gray-100">
                <!-- üìß Toggle Email Notification -->
                <li>
                  <button
                    id="toggle-email-btn"
                    type="button"
                    class="w-full text-left px-4 py-2.5 text-sm flex items-center justify-between hover:bg-gray-50 transition"
                  >
                    <div class="flex items-center gap-2 text-gray-700">
                      <span class="text-[16px]">üìß</span>
                      <span id="email-toggle-text" class="font-medium">
                        T·∫Øt th√¥ng b√°o qua Gmail
                      </span>
                    </div>
                    <!-- üîò Switch -->
                    <div
                      id="email-toggle-icon"
                      class="w-9 h-5 flex items-center bg-gray-300 rounded-full p-0.5 transition-all duration-300"
                    >
                      <div
                        class="dot bg-white w-4 h-4 rounded-full transform translate-x-0 transition-all duration-300"
                      ></div>
                    </div>
                  </button>
                </li>

                <li>
                  <a
                    id="open-settings-link"
                    href="/settings/notifications"
                    class="block w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-gray-50 flex items-center gap-2 transition"
                  >
                    <span class="text-[16px]">‚öôÔ∏è</span>
                    <span class="font-medium">T·∫•t c·∫£ c√†i ƒë·∫∑t th√¥ng b√°o</span>
                  </a>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- Empty State -->
      <div
        id="notif-empty"
        class="hidden flex flex-col items-center justify-center py-16"
      >
        <img
          src="https://cdn-icons-png.flaticon.com/512/616/616408.png"
          alt="empty"
          class="w-24 h-24 opacity-80 mb-3"
        />
        <p class="text-gray-500 text-sm font-medium">No unread notifications</p>
      </div>

      <!-- List (render ƒë·ªông) -->
      <div
        id="notif-list"
        class="max-h-[480px] overflow-y-auto divide-y divide-gray-100"
      >
        <!-- JS s·∫Ω render n·ªôi dung v√†o ƒë√¢y -->
      </div>
    </div>

    <!-- üë§ User info -->
    <div class="relative">
      <div
        id="userMenuButton"
        class="flex items-center space-x-3 cursor-pointer p-1 rounded-full hover:bg-gray-100 transition"
      >
        <div class="text-right leading-tight">
          <div class="flex items-center justify-end space-x-2">
            <span
              class="block text-sm font-semibold text-gray-800"
              th:text="${user != null ? user.name : 'User'}"
            >
              User
            </span>

            <!-- üèÜ Premium -->
            <span
              th:if="${user != null && user.isPremium}"
              class="bg-yellow-400 text-white text-[11px] font-bold px-2 py-0.5 rounded-full shadow-sm flex items-center space-x-1"
              title="T√†i kho·∫£n Premium"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="currentColor"
                viewBox="0 0 20 20"
                class="w-3.5 h-3.5"
              >
                <path
                  fill-rule="evenodd"
                  d="M10 2a1 1 0 01.894.553l1.382 2.802
                     3.09.45a1 1 0 01.554 1.707l-2.236
                     2.18.528 3.078a1 1 0 01-1.45
                     1.054L10 12.347l-2.762
                     1.457a1 1 0 01-1.45-1.054l.528-3.078-2.236-2.18a1
                     1 0 01.554-1.707l3.09-.45L9.106
                     2.553A1 1 0 0110 2z"
                  clip-rule="evenodd"
                />
              </svg>
              <span>Premium</span>
            </span>

            <!-- üÜì Free -->
            <span
              th:if="${user != null && !user.isPremium}"
              class="bg-gray-200 text-gray-600 text-[11px] font-medium px-2 py-0.5 rounded-full shadow-sm"
              title="T√†i kho·∫£n mi·ªÖn ph√≠"
            >
              Free
            </span>
          </div>

          <span
            class="block text-xs text-gray-500"
            th:text="${user != null ? user.email : ''}"
          >
            user@email.com
          </span>
        </div>

        <!-- Avatar -->
        <img
          th:src="${user != null && user.avatarUrl != null && !#strings.isEmpty(user.avatarUrl)
                   ? user.avatarUrl : '/photo/default-avatar.png'}"
          class="rounded-full w-10 h-10 border-2 border-white shadow-lg object-cover"
          alt="User Avatar"
        />
      </div>

      <!-- Dropdown -->
      <div
        id="userDropdown"
        class="hidden absolute right-0 mt-3 w-44 bg-white border border-gray-200 rounded-xl shadow-lg z-30"
      >
        <a
          href="/user/view/profile"
          class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-t-xl"
        >
          üë§ Profile
        </a>
        <a
          href="#"
          id="logoutBtn"
          class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-b-xl"
        >
          üö™ Logout
        </a>
      </div>
    </div>
  </div>

  <!-- WebSocket libs -->
  <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/stompjs@2/dist/stomp.min.js"></script>

  <!-- HEADER SCRIPT (PERFORMANCE VERSION) -->
  <script th:inline="javascript">
    document.addEventListener("DOMContentLoaded", function () {
      (function (window, document) {
        // ================== üß† STATE ==================
        const state = {
          user: null,
          notifications: [],
          notifLoadedAt: 0,
          notifLoading: false,
          wsClient: null,
          wsConnected: false,
          wsRetry: 0,
          wsMaxRetry: 8,
          wsBaseDelay: 1000,
          wsMaxDelay: 30000,
          notifPanelOpen: false,
          notifFilterUnread: false,
          searchAbortController: null,
        };

        // ================== üîó DOM ==================
        const dom = {
          notifBtn: document.getElementById("open-notif-btn"),
          notifPanel: document.getElementById("notif-panel"),
          notifList: document.getElementById("notif-list"),
          notifEmpty: document.getElementById("notif-empty"),
          toggleUnread: document.getElementById("toggle-unread"),
          notifDot: document.getElementById("notif-dot"),
          notifCountBadge: document.getElementById("notif-count-badge"),
          markAllBtn: document.getElementById("mark-all-read"),
          notifMenuBtn: document.getElementById("notif-options-btn"),
          notifMenu: document.getElementById("notif-options-menu"),
          toggleEmailBtn: document.getElementById("toggle-email-btn"),
          emailToggleText: document.getElementById("email-toggle-text"),
          openSettingsLink: document.getElementById("open-settings-link"),
          userBtn: document.getElementById("userMenuButton"),
          userDropdown: document.getElementById("userDropdown"),
          logoutBtn: document.getElementById("logoutBtn"),
          searchInput: document.getElementById("searchInput"),
          searchDropdown: document.getElementById("searchDropdown"),
          searchResults: document.getElementById("searchResults"),
        };

        // user header elements
        const userHeaderDom = {
          nameEl: document.querySelector("#userMenuButton span[th\\:text]"),
          emailEl: document.querySelector("#userMenuButton .text-xs"),
          freeBadge: document.querySelector("#userMenuButton .bg-gray-200"),
          premiumBadge: document.querySelector(
            "#userMenuButton .bg-yellow-400"
          ),
          avatarImg: document.querySelector(
            '#userMenuButton img[alt="User Avatar"]'
          ),
        };

        // ================== üîß HELPERS ==================
        function getLocalToken() {
          return (
            localStorage.getItem("token") ||
            localStorage.getItem("AUTH_TOKEN") ||
            ""
          );
        }

        function getAuthHeaders() {
          const token = getLocalToken();
          return token
            ? {
                Authorization: "Bearer " + token,
              }
            : {};
        }

        function escapeHtml(unsafe) {
          if (typeof unsafe !== "string") return "";
          return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
        }

        function formatRelativeTime(isoString) {
          if (!isoString) return "";
          const now = new Date();
          const date = new Date(isoString);
          const diffMin = Math.floor((now - date) / 60000);
          if (diffMin < 1) return "just now";
          if (diffMin < 60) return diffMin + " mins ago";
          const hrs = Math.floor(diffMin / 60);
          if (hrs < 24) return hrs + " hours ago";
          const days = Math.floor(hrs / 24);
          return days + " days ago";
        }

        function updateUnreadBadge(count) {
          if (!dom.notifCountBadge) return;
          const c = Number(count) || 0;
          if (c <= 0) {
            dom.notifCountBadge.classList.add("hidden");
            dom.notifCountBadge.textContent = "";
            dom.notifDot && dom.notifDot.classList.add("hidden");
          } else {
            dom.notifCountBadge.classList.remove("hidden");
            dom.notifCountBadge.textContent = c > 99 ? "99+" : String(c);
            dom.notifDot && dom.notifDot.classList.remove("hidden");
          }
        }

        function incrementUnreadBadge() {
          if (!dom.notifCountBadge) return;
          if (state.notifPanelOpen) return; // ƒëang m·ªü th√¨ s·∫Ω reload list
          const cur = parseInt(dom.notifCountBadge.textContent) || 0;
          updateUnreadBadge(cur + 1);
        }

        function backoffDelay(attempt) {
          const expo = Math.min(
            state.wsMaxDelay,
            state.wsBaseDelay * Math.pow(2, attempt)
          );
          return Math.floor(expo * (0.7 + Math.random() * 0.6));
        }

        function safeShowToast(msg) {
          if (typeof window.showToast === "function") {
            window.showToast(msg);
          } else {
            console.log("TOAST:", msg);
          }
        }

        function safeShowToastNotification(title, message, avatar, senderName) {
          if (typeof window.showToastNotification === "function") {
            window.showToastNotification(title, message, avatar, senderName);
          } else {
            console.log("NOTIF:", title, message);
          }
        }

        // ================== üë§ USER HEADER ==================
        async function fetchCurrentUser() {
          if (state.user) return state.user;
          try {
            const res = await fetch("/api/auth/me", {
              headers: getAuthHeaders(),
              credentials: "include",
            });
            if (!res.ok) throw new Error("Unauthorized");
            const data = await res.json();
            const u = data.user || data;
            state.user = {
              name: u.name || u.fullName || "User",
              email: u.email || "",
              avatarUrl:
                u.avatarUrl && u.avatarUrl.trim() !== "" ? u.avatarUrl : "",
              isPremium:
                !!u.isPremium ||
                (Array.isArray(u.roles) && u.roles.includes("ROLE_PREMIUM")),
            };
            return state.user;
          } catch (err) {
            console.warn("‚ö†Ô∏è fetchCurrentUser failed:", err);
            return null;
          }
        }

        async function initUserHeader() {
          const { nameEl, emailEl, freeBadge, premiumBadge, avatarImg } =
            userHeaderDom;

          // N·∫øu Thymeleaf ƒë√£ render ƒë·∫ßy ƒë·ªß th√¨ kh√¥ng fetch n·ªØa
          if (
            nameEl &&
            nameEl.textContent.trim() !== "User" &&
            emailEl &&
            emailEl.textContent.trim() !== ""
          ) {
            return;
          }

          const user = await fetchCurrentUser();
          if (!user) return;

          if (nameEl) nameEl.textContent = user.name;
          if (emailEl) emailEl.textContent = user.email;

          if (user.isPremium) {
            freeBadge && freeBadge.classList.add("hidden");
            premiumBadge && premiumBadge.classList.remove("hidden");
          } else {
            premiumBadge && premiumBadge.classList.add("hidden");
            freeBadge && freeBadge.classList.remove("hidden");
          }

          if (avatarImg) {
            if (user.avatarUrl) {
              avatarImg.src = user.avatarUrl;
            } else {
              // T·∫°o avatar ch·ªØ c√°i ƒë·∫ßu (canvas)
              const canvas = document.createElement("canvas");
              canvas.width = 100;
              canvas.height = 100;
              const ctx = canvas.getContext("2d");
              ctx.fillStyle = "#2563eb";
              ctx.beginPath();
              ctx.arc(50, 50, 50, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = "#fff";
              ctx.font = "bold 50px Inter, sans-serif";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(user.name.charAt(0).toUpperCase(), 50, 55);
              avatarImg.src = canvas.toDataURL();
            }
          }
        }

        // ================== üîî NOTIFICATIONS ==================
        function renderNotifications() {
          const list = state.notifications || [];
          const onlyUnread = state.notifFilterUnread;

          const filtered = onlyUnread
            ? list.filter((n) => n.status && n.status.toLowerCase() !== "read")
            : list;

          if (!dom.notifList || !dom.notifEmpty) return;

          if (filtered.length === 0) {
            dom.notifEmpty.classList.remove("hidden");
            dom.notifList.innerHTML = "";
            dom.markAllBtn && dom.markAllBtn.classList.add("hidden");
            dom.notifDot && dom.notifDot.classList.add("hidden");
            return;
          }

          dom.notifEmpty.classList.add("hidden");
          dom.markAllBtn && dom.markAllBtn.classList.remove("hidden");

          const html = filtered
            .map((n) => {
              const id = n.notificationId || n.id;
              const link = n.link || "#";
              const msg = n.message || "";
              const createdAt = n.createdAt || new Date().toISOString();
              const isRead = n.status && n.status.toLowerCase() === "read";
              const senderName = n.senderName || "H·ªá th·ªëng";
              const senderAvatar =
                n.senderAvatar && n.senderAvatar.trim() !== ""
                  ? n.senderAvatar
                  : "https://cdn-icons-png.flaticon.com/512/149/149071.png";

              return `
                <div 
                  class="bg-white px-4 py-3 hover:bg-gray-50 transition cursor-pointer relative border-b border-gray-100 ${
                    isRead ? "opacity-60" : ""
                  }"
                  data-notif-id="${id}"
                  data-notif-link="${encodeURIComponent(link)}"
                >
                  <div class="flex items-start gap-3">
                    <img 
                      src="${senderAvatar}" 
                      class="w-9 h-9 rounded-full border object-cover" 
                      alt="avatar"
                    />
                    <div class="flex-1 text-sm">
                      <p class="text-gray-800 font-medium">${escapeHtml(
                        senderName
                      )}</p>
                      <p class="text-gray-700 leading-snug">${escapeHtml(
                        msg
                      )}</p>
                      <p class="text-xs text-gray-400 mt-1">${formatRelativeTime(
                        createdAt
                      )}</p>
                    </div>
                    ${
                      !isRead
                        ? `<span class="absolute right-3 top-3 w-2.5 h-2.5 bg-blue-500 rounded-full"></span>`
                        : ""
                    }
                  </div>
                </div>
              `;
            })
            .join("");

          dom.notifList.innerHTML = html;
        }

        async function loadNotifications(force = false) {
          if (!dom.notifList || !dom.notifEmpty) return;
          if (state.notifLoading) return;

          const now = Date.now();
          // cache 10s khi panel ƒëang m·ªü, tr√°nh spam server
          if (
            !force &&
            now - state.notifLoadedAt < 10000 &&
            state.notifications.length > 0
          ) {
            renderNotifications();
            return;
          }

          state.notifLoading = true;
          dom.notifList.innerHTML =
            '<p class="text-gray-400 text-sm italic text-center py-4">Loading...</p>';
          dom.notifEmpty.classList.add("hidden");

          try {
            const res = await fetch("/api/notifications", {
              headers: getAuthHeaders(),
              credentials: "include",
            });
            if (!res.ok)
              throw new Error("Failed to fetch notifications: " + res.status);

            const data = await res.json();
            const list = Array.isArray(data)
              ? data
              : data.content || data.notifications || data.data || [];

            state.notifications = list;
            state.notifLoadedAt = Date.now();

            const totalUnread = list.filter(
              (n) => n.status && n.status.toLowerCase() !== "read"
            ).length;
            updateUnreadBadge(totalUnread);

            const hasUnread = totalUnread > 0;
            dom.notifDot && dom.notifDot.classList.toggle("hidden", !hasUnread);

            renderNotifications();
          } catch (err) {
            console.error("‚ùå loadNotifications:", err);
            dom.notifList.innerHTML =
              '<p class="text-red-500 text-sm text-center py-4">Failed to load notifications</p>';
          } finally {
            state.notifLoading = false;
          }
        }

        async function markNotificationRead(id) {
          if (!id) return;
          try {
            await fetch(`/api/notifications/${id}/read`, {
              method: "PUT",
              headers: getAuthHeaders(),
              credentials: "include",
            });
            // c·∫≠p nh·∫≠t local state
            state.notifications = state.notifications.map((n) =>
              (n.notificationId || n.id) === id ? { ...n, status: "READ" } : n
            );
          } catch (err) {
            console.error("‚ùå markNotificationRead:", err);
          }
        }

        async function markAllNotificationsRead() {
          try {
            const res = await fetch("/api/notifications/read-all", {
              method: "PUT",
              headers: getAuthHeaders(),
              credentials: "include",
            });
            if (!res.ok) throw new Error("Failed to mark all as read");

            // update local
            state.notifications = state.notifications.map((n) => ({
              ...n,
              status: "READ",
            }));
            updateUnreadBadge(0);
            dom.notifDot && dom.notifDot.classList.add("hidden");
            renderNotifications();
          } catch (err) {
            console.error("‚ùå markAllNotificationsRead:", err);
          }
        }

        async function openTaskDetailFromApi(taskId) {
          try {
            const res = await fetch(`/api/tasks/${taskId}`, {
              headers: getAuthHeaders(),
              credentials: "include",
            });
            if (!res.ok) throw new Error("Failed to load task");
            const task = await res.json();
            if (typeof window.openTaskModal === "function") {
              window.openTaskModal(task);
            } else {
              // fallback: ƒë∆°n gi·∫£n redirect
              window.location.href = `/view/pm/task?taskId=${taskId}`;
            }
          } catch (err) {
            console.error("‚ùå openTaskDetailFromApi:", err);
            alert("Kh√¥ng th·ªÉ t·∫£i th√¥ng tin c√¥ng vi·ªác.");
          }
        }

        async function handleNotificationItemClick(target) {
          const wrapper = target.closest("[data-notif-id]");
          if (!wrapper) return;

          const id = Number(wrapper.getAttribute("data-notif-id"));
          const link = decodeURIComponent(
            wrapper.getAttribute("data-notif-link") || "#"
          );

          await markNotificationRead(id);

          // Gi·∫£m local badge
          const cur = parseInt(dom.notifCountBadge?.textContent) || 0;
          if (cur > 0) updateUnreadBadge(cur - 1);

          if (!link || link === "#" || link === "null") {
            return;
          }

          if (link.includes("/tasks/") || link.includes("taskId=")) {
            const taskId =
              link.split("taskId=")[1] ||
              link.split("/tasks/")[1] ||
              link.split("/").pop();
            if (taskId) {
              await openTaskDetailFromApi(taskId);
              return;
            }
          }

          if (link.startsWith("/view/pm/project/")) {
            window.location.href = link;
            return;
          }

          // m·∫∑c ƒë·ªãnh m·ªü tab m·ªõi
          window.open(link, "_blank");
        }

        // ================== üì° WEBSOCKET ==================
        function scheduleWsReconnect() {
          if (state.wsConnected) return;
          if (state.wsRetry >= state.wsMaxRetry) {
            console.error("üö´ WS max retries reached ‚Äî stop reconnecting");
            return;
          }
          const delay = backoffDelay(state.wsRetry);
          console.log(
            `‚è≥ WS reconnect in ${Math.round(delay / 1000)}s (attempt ${
              state.wsRetry + 1
            }/${state.wsMaxRetry})`
          );
          setTimeout(() => {
            state.wsRetry++;
            connectWebSocketNotifications();
          }, delay);
        }

        function connectWebSocketNotifications() {
          if (state.wsClient && state.wsConnected) return;

          const socket = new SockJS("/ws");
          const client = Stomp.over(socket);
          client.heartbeat.outgoing = 15000;
          client.heartbeat.incoming = 15000;

          const headers = getAuthHeaders();

          client.connect(
            headers,
            (frame) => {
              console.log("‚úÖ WS connected:", frame);
              state.wsClient = client;
              state.wsConnected = true;
              state.wsRetry = 0;

              client.subscribe("/user/queue/notifications", (message) => {
                try {
                  const notif = JSON.parse(message.body);
                  console.log("üîî Realtime notif:", notif);
                  incrementUnreadBadge();
                  safeShowToastNotification(
                    notif.title || "Notification",
                    notif.message || "",
                    notif.senderAvatar,
                    notif.senderName || "System"
                  );

                  // c·∫≠p nh·∫≠t state local
                  if (notif) {
                    state.notifications.unshift(notif);
                    if (state.notifications.length > 200) {
                      state.notifications.pop();
                    }
                    if (state.notifPanelOpen) {
                      renderNotifications();
                    }
                  }
                } catch (e) {
                  console.error("‚ùå WS message parse:", e);
                }
              });
            },
            (error) => {
              console.warn("‚ö†Ô∏è WS connect ERROR:", error);
              state.wsConnected = false;
              scheduleWsReconnect();
            }
          );

          socket.onclose = () => {
            console.warn("‚ö†Ô∏è WS closed");
            state.wsConnected = false;
            scheduleWsReconnect();
          };
        }

        // ================== üîé SEARCH ==================
        function clearSearchDropdownIfNeeded(e) {
          if (
            dom.searchDropdown &&
            !dom.searchDropdown.contains(e.target) &&
            e.target !== dom.searchInput
          ) {
            dom.searchDropdown.classList.add("hidden");
          }
        }

        function initSearch() {
          if (!dom.searchInput || !dom.searchDropdown || !dom.searchResults) {
            return;
          }

          dom.searchInput.addEventListener("focus", () => {
            dom.searchDropdown.classList.remove("hidden");
            dom.searchResults.innerHTML =
              "<p class='p-4 text-gray-500 text-sm text-center'>Nh·∫≠p ƒë·ªÉ b·∫Øt ƒë·∫ßu t√¨m ki·∫øm...</p>";
          });

          document.addEventListener("click", clearSearchDropdownIfNeeded);

          let timeoutId = null;

          dom.searchInput.addEventListener("input", () => {
            const query = dom.searchInput.value.trim();
            if (state.searchAbortController) {
              state.searchAbortController.abort();
            }

            clearTimeout(timeoutId);

            if (query.length < 2) {
              dom.searchResults.innerHTML =
                "<p class='p-4 text-gray-500 text-sm text-center'>Nh·∫≠p ƒë·ªÉ b·∫Øt ƒë·∫ßu t√¨m ki·∫øm...</p>";
              return;
            }

            timeoutId = setTimeout(async () => {
              try {
                state.searchAbortController = new AbortController();
                const res = await fetch(
                  `/api/search?query=${encodeURIComponent(query)}`,
                  { signal: state.searchAbortController.signal }
                );
                if (!res.ok) throw new Error("Search error");
                const data = await res.json();
                if (!data || data.length === 0) {
                  dom.searchResults.innerHTML =
                    "<p class='p-4 text-gray-500 text-sm text-center'>Kh√¥ng c√≥ k·∫øt qu·∫£</p>";
                  return;
                }

                dom.searchResults.innerHTML = data
                  .map(
                    (item) => `
                      <div 
                        class="px-4 py-3 hover:bg-gray-50 border-b border-gray-100 cursor-pointer transition"
                        data-project-id="${item.projectId}"
                      >
                        <p class="text-sm font-medium text-gray-800">
                          ${escapeHtml(item.name || "")}
                        </p>
                        <p class="text-xs text-gray-500">
                          ${
                            item.description ? escapeHtml(item.description) : ""
                          }
                        </p>
                      </div>
                    `
                  )
                  .join("");
              } catch (err) {
                if (err.name === "AbortError") return;
                console.error("‚ùå search error:", err);
                dom.searchResults.innerHTML =
                  "<p class='p-4 text-gray-500 text-sm text-center'>Kh√¥ng th·ªÉ t·∫£i k·∫øt qu·∫£</p>";
              }
            }, 300);
          });

          dom.searchResults.addEventListener("click", (e) => {
            const row = e.target.closest("[data-project-id]");
            if (!row) return;
            const pid = row.getAttribute("data-project-id");
            if (pid) {
              window.location.href = `/view/project/${pid}`;
            }
          });
        }

        // ================== ‚öôÔ∏è SETTINGS LINK ==================
        function initSettingsLink() {
          if (!dom.openSettingsLink) return;

          dom.openSettingsLink.addEventListener("click", async (e) => {
            e.preventDefault();

            try {
              const meRes = await fetch("/api/auth/me", {
                headers: getAuthHeaders(),
                credentials: "include",
              });

              if (!meRes.ok) {
                // session / token h·∫øt h·∫°n ‚Üí clear local v√† v·ªÅ signin
                localStorage.removeItem("token");
                localStorage.removeItem("AUTH_TOKEN");
                localStorage.removeItem("REFRESH_TOKEN");
                alert("‚ö†Ô∏è Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n, vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.");
                window.location.href = "/view/signin";
                return;
              }

              const userData = await meRes.json();
              if (userData.email) {
                localStorage.setItem("currentUserEmail", userData.email);
              }

              const res = await fetch("/api/settings/notifications/me", {
                headers: getAuthHeaders(),
                credentials: "include",
              });

              if (!res.ok) {
                alert(
                  "‚ùå Kh√¥ng th·ªÉ truy c·∫≠p trang c√†i ƒë·∫∑t. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i!"
                );
                window.location.href = "/view/signin";
                return;
              }

              // ok
              window.location.href = "/settings/notifications";
            } catch (err) {
              console.error("‚ö†Ô∏è openSettingsLink error:", err);
              alert("‚ùå L·ªói k·∫øt n·ªëi. Vui l√≤ng th·ª≠ l·∫°i sau.");
            }
          });
        }

        // ================== üë§ USER DROPDOWN & LOGOUT ==================
        function initUserDropdown() {
          if (!dom.userBtn || !dom.userDropdown) return;

          dom.userBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            dom.userDropdown.classList.toggle("hidden");
          });

          document.addEventListener("click", (e) => {
            if (
              !dom.userDropdown.contains(e.target) &&
              !dom.userBtn.contains(e.target)
            ) {
              dom.userDropdown.classList.add("hidden");
            }
          });
        }

        function initLogout() {
          if (!dom.logoutBtn) return;
          dom.logoutBtn.addEventListener("click", (e) => {
            e.preventDefault();
            fetch("/api/auth/logout", {
              method: "POST",
              credentials: "include",
            })
              .then(() => {
                // clear local
                localStorage.removeItem("token");
                localStorage.removeItem("AUTH_TOKEN");
                localStorage.removeItem("REFRESH_TOKEN");

                // clear cookies (FE side)
                document.cookie =
                  "AUTH_TOKEN=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
                document.cookie =
                  "REFRESH_TOKEN=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";

                window.location.href = "/view/signin";
              })
              .catch((err) => console.error("Logout error:", err));
          });
        }

        // ================== üîî NOTIF UI BINDINGS ==================
        function initNotificationUI() {
          if (!dom.notifBtn || !dom.notifPanel) return;

          dom.notifBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            const willOpen = dom.notifPanel.classList.contains("hidden");
            dom.notifPanel.classList.toggle("hidden");
            state.notifPanelOpen = willOpen;
            if (willOpen) {
              loadNotifications(false);
            }
          });

          document.addEventListener("click", (e) => {
            if (
              dom.notifPanel &&
              !dom.notifPanel.contains(e.target) &&
              !dom.notifBtn.contains(e.target)
            ) {
              dom.notifPanel.classList.add("hidden");
              state.notifPanelOpen = false;
            }
          });

          if (dom.toggleUnread) {
            dom.toggleUnread.addEventListener("change", (e) => {
              state.notifFilterUnread = e.target.checked;
              renderNotifications();
            });
          }

          if (dom.markAllBtn) {
            dom.markAllBtn.addEventListener("click", () => {
              markAllNotificationsRead();
            });
          }

          // menu ‚ãØ
          if (dom.notifMenuBtn && dom.notifMenu) {
            dom.notifMenuBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              dom.notifMenu.classList.toggle("hidden");
            });

            document.addEventListener("click", (e) => {
              if (
                dom.notifMenu &&
                !dom.notifMenu.contains(e.target) &&
                !dom.notifMenuBtn.contains(e.target)
              ) {
                dom.notifMenu.classList.add("hidden");
              }
            });
          }

          if (dom.toggleEmailBtn && dom.emailToggleText) {
            let emailEnabled = true;
            dom.toggleEmailBtn.addEventListener("click", async (e) => {
              e.preventDefault();
              e.stopPropagation();

              emailEnabled = !emailEnabled;
              try {
                const res = await fetch(
                  "/api/settings/notifications/email-toggle",
                  {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      ...getAuthHeaders(),
                    },
                    credentials: "include",
                    body: JSON.stringify({ enabled: emailEnabled }),
                  }
                );
                if (res.ok) {
                  dom.emailToggleText.textContent = emailEnabled
                    ? "T·∫Øt th√¥ng b√°o qua Gmail"
                    : "B·∫≠t l·∫°i th√¥ng b√°o qua Gmail";
                  safeShowToast(
                    emailEnabled
                      ? "‚úÖ ƒê√£ b·∫≠t l·∫°i th√¥ng b√°o Gmail"
                      : "üö´ ƒê√£ t·∫Øt th√¥ng b√°o Gmail"
                  );
                } else {
                  safeShowToast("‚ö†Ô∏è Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t c√†i ƒë·∫∑t.");
                }
              } catch (err) {
                console.error("‚ùå toggleEmailBtn error:", err);
                safeShowToast("‚ö†Ô∏è L·ªói k·∫øt n·ªëi server.");
              } finally {
                dom.notifMenu && dom.notifMenu.classList.add("hidden");
              }
            });
          }

          // delegate click notification item
          if (dom.notifList) {
            dom.notifList.addEventListener("click", (e) => {
              handleNotificationItemClick(e.target);
            });
          }

          // Auto refresh m·ªói 30s khi panel m·ªü
          setInterval(() => {
            if (
              state.notifPanelOpen &&
              document.visibilityState === "visible"
            ) {
              loadNotifications(false);
            }
          }, 30000);
        }

        // ================== INIT ==================
        function init() {
          initUserHeader();
          initNotificationUI();
          initSearch();
          initSettingsLink();
          initUserDropdown();
          initLogout();

          // WebSocket
          window.addEventListener("load", () => {
            try {
              connectWebSocketNotifications();
            } catch (err) {
              console.warn("‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi t·∫°o WebSocket:", err);
            }
          });
        }

        init();
      })(window, document);
    });
  </script>
</header>
